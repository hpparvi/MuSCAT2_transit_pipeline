#!/usr/bin/env python
import warnings

from warnings import simplefilter, catch_warnings
from argparse import ArgumentParser
from multiprocessing import Pool
from pathlib import Path
from os import makedirs
from datetime import datetime, timedelta

import matplotlib as mpl
mpl.use('Agg')
import matplotlib.pyplot as pl
import xarray as xa
from numpy import median, zeros, inf, array, fromstring, c_, nan, full_like
from tqdm import tqdm
from astropy.io import fits as pf
from astropy.wcs.wcs import NoConvergence
from astropy.coordinates import SkyCoord, FK5
from astroquery.simbad import Simbad
import astropy.units as u


from muscat2ph.photometry import ScienceFrame, COMCentroider

passbands = 'g r i z_s'.split()

def init(root, pb, stars_file, apertures):
    isize = 1024
    global im, cc
    im = ScienceFrame(root, pb, aperture_radii=apertures)
    im.aperture_radii = apertures
    im.napt = len(apertures)
    im.load_reference_stars(stars_file)
    im._data = zeros((isize, isize))
    cc = COMCentroider(im, None, aperture_radius=15)
    cc.select_stars(20)

def photometry(filename):
    try:
        im.load_fits(filename)
        cc.calculate_and_apply()
        aux = [im._header['airmass'],
               im._header['exptime'],
               im._header['mjd-strt'] + 0.5 * im._header['exptime'] / 24 / 60 / 60]
        aux = xa.DataArray(aux, dims='quantity', coords={'quantity':'airmass exptime mjd'.split()})
        return im.photometry(centroid=False) + (aux,)
    except NoConvergence:
        return None

def create_datacube(filename):
    im.load_fits(filename)
    cc.calculate_and_apply()
    return im.get_aperture(5)


def get_sky_coordinates(names):
    assert isinstance(['ds'], (str, list, tuple))
    names = (names,) if isinstance(names, str) else names
    with catch_warnings():
        simplefilter('ignore', UserWarning)
        for name in names:
            obj = Simbad.query_object(name)
            if obj:
                return SkyCoord(obj['RA'][0], obj['DEC'][0], frame=FK5, unit=(u.hourangle, u.deg))


if __name__ == '__main__':
    ap = ArgumentParser()
    ap.add_argument('datadir', type=str)
    ap.add_argument('--object', type=str, default=None)
    ap.add_argument('--passband', choices='g r i z_s all'.split(), default='all')
    ap.add_argument('--target-catalog-name', type=str, default=None)
    ap.add_argument('--target-sky-coords', type=str, default=None)
    ap.add_argument('--target-pix-coords', type=str, default=None)
    ap.add_argument('--result-dir', type=Path, default=None)
    ap.add_argument('--max-stars', type=int, default=15)
    ap.add_argument('--edge-limit', type=float, default=30)
    ap.add_argument('--start-frame', type=int, default=0)
    ap.add_argument('--end-frame', type=int, default=inf)
    ap.add_argument('--with-wcs-only', action='store_true', default=False)
    ap.add_argument('--plot-only', action='store_false', dest='do_photometry', default=True)
    ap.add_argument('--n-processes', type=int, default=5)
    ap.add_argument('--chunksize', type=int, default=5)
    ap.add_argument('--save-stars', action='store_true', default=False)
    ap.add_argument('--create-dc', action='store_true', default=False)
    ap.add_argument('--tfop', action='store_true', default=False)
    ap.add_argument('--border-margin', type=int, default=30)
    ap.add_argument('--apply-separation-cut', action='store_true', default=False)
    ap.add_argument('--separation-cut-distance', type=float, default=2.0)
    args = ap.parse_args()

    root = Path(args.datadir)
    pbs = [args.passband] if args.passband != 'all' else 'r g i z_s'.split()
    target_sky_coords = None
    target_pix_coords = None

    # Set up the defaults
    # -------------------
    if args.tfop:
        apertures = (4, 8, 12, 16, 20)
        max_stars = 200
    else:
        apertures  = (6, 8, 12, 16, 20, 24, 30, 40, 50, 60)
        max_stars = args.max_stars

    objects = [args.object] if args.object else [o.name for o in list(root.joinpath('obj').glob('*'))]

    # Get the sky and pixel coordinates for the target if a single target is defined
    # ------------------------------------------------------------------------------
    if args.object:
        if args.target_sky_coords is not None:
            target_sky_coords = SkyCoord(args.target_sky_coords, frame=FK5, unit=(u.hourangle, u.deg))
        else:
            target_sky_coords = get_sky_coordinates([args.target_catalog_name, args.object])
        if target_sky_coords is None and args.target_pix_coords:
            try:
                target_pix_coords = fromstring(args.target_pix_coords, sep=',')
            except TypeError:
                pass

    # Do the photometry for all the targets
    # -------------------------------------
    for object in objects:
        all_files = {pb : sorted(list(root.joinpath('obj', object, pb).glob('MCT2?_*.fits'))) for pb in pbs}
        if args.with_wcs_only:
            all_files = {pb : list(filter(lambda f: f.with_suffix('.wcs').exists(), all_files[pb])) for pb in all_files.keys()}

        for k, it in all_files.items():
            if len(it) > 0:
                h = pf.getheader(it[0])
                break

        obsnight = datetime.strptime(h['date-obs'], '%Y-%m-%d')
        if h['MJD-STRT'] % 1 < 0.5:
            obsnight -= timedelta(1)

        if args.result_dir:
            rdir = Path(args.result_dir)
        else:
            rdir = Path('.').resolve().joinpath(object, obsnight.strftime('%y%m%d'))
            if not rdir.exists():
                makedirs(rdir)

        stars_file = rdir.joinpath('{}_stars.fits'.format(object))
        for ipb, pb in enumerate(pbs):
            files = all_files[pb]
            istart = max(0, args.start_frame)
            iend = min(args.end_frame, len(files))
            files = files[istart:iend]
            im = ScienceFrame(root, pb, aperture_radii=apertures)
            if target_sky_coords is not None:
                im._target_center = target_sky_coords
            im.load_fits(files[0])

            # Find, cut, save, and load the stars
            # -----------------------------------
            if (args.save_stars and ipb==0) or not stars_file.exists():
                if args.tfop:
                    im.find_stars_dao(maxn=150)
                else:
                    im.find_stars(maxn=max_stars, target_sky=target_sky_coords, target_pix=target_pix_coords)
                im.cut_margin(args.border_margin)
                if args.tfop or args.apply_separation_cut:
                    im.cut_separation(target_sky_coords, args.separation_cut_distance)
                im.save_reference_stars(stars_file)

            im.load_reference_stars(stars_file)

            # Masterframe plot with apertures
            # -------------------------------
            fig1 = pl.figure(figsize=(9,9))
            if im._wcs:
                ax1 = fig1.add_subplot(111, projection=im._wcs)
                ax1.grid()
            else:
                ax1 = fig1.add_subplot(111)
            _, ax1 = im.plot_reduced(minp=90, offset=10, ax=ax1)
            ax1.set_title('Reference frame - {} {}'.format(object, pb))
            fig1.tight_layout()
            fig1.savefig(str(rdir.joinpath('{}_{}_{}.png'.format(object, root.absolute().name, pb))))

            if args.tfop and im._target_center is not None:
                for r in [5,2]:
                    fig = pl.figure(figsize=(9, 9))
                    ax = fig.add_subplot(111, projection=im._wcs)
                    ax.grid()
                    im.plot_reduced(ax=ax, minp=90, offset=10, subfield_radius=r)
                    ax.set_title("Reference frame - {} {} {:d}'".format(object, pb, r))
                    pl.setp(ax, ylabel='Dec', xlabel='RA')
                    fig.tight_layout()
                    fig.subplots_adjust(bottom=0.03, top=0.98, left=0.13, right=0.98)
                    fig.savefig(str(rdir.joinpath('{}_{}_{}_{:d}am.png'.format(object, root.absolute().name, pb, r))))

            # Datacube creation
            # -----------------
            if args.create_dc:
                with Pool(processes=args.n_processes, initializer=init, initargs=(root, pb, stars_file, apertures)) as pool:
                    dc = array(list(tqdm(pool.imap(create_datacube, files, chunksize=args.chunksize), total=len(files))))
                    hdu = pf.PrimaryHDU(dc)
                    hdu.writeto(str(rdir.joinpath('{}_{}_{}-dc.fits'.format(object, root.absolute().name, pb))), overwrite=True)

            # Photometry
            # ----------
            if args.do_photometry:
                with Pool(processes=args.n_processes, initializer=init, initargs=(root, pb, stars_file, apertures)) as pool:
                    result = list(tqdm(pool.imap(photometry, files, chunksize=args.chunksize), total=len(files)))
                result = list(filter(lambda r:r is not None, result))

                aux  = xa.concat([r[5] for r in result], 'frame')
                ctime = xa.IndexVariable('mjd', aux.loc[:,'mjd'])
                flux = xa.concat([r[0] for r in result], 'mjd').assign_coords(mjd = ctime)
                msky = xa.concat([r[1] for r in result], 'mjd').assign_coords(mjd = ctime)
                eobj = xa.concat([r[2] for r in result], 'mjd').assign_coords(mjd = ctime)
                esky = xa.concat([r[3] for r in result], 'mjd').assign_coords(mjd = ctime)
                cpos = xa.concat([r[4] for r in result], 'mjd').assign_coords(mjd = ctime)

                cpix = xa.DataArray(im._ref_centroids_pix,
                                    name='centroids_pix',
                                    dims='star centroid_pix'.split(),
                                    coords={'centroid_pix': ['x', 'y']})

                if im._ref_centroids_sky is not None:
                    ca = c_[im._ref_centroids_sky.ra.deg, im._ref_centroids_sky.dec.deg]
                else:
                    ca = full_like(array(cpix), nan)

                csky = xa.DataArray(ca,
                                    name='centroids_sky',
                                    dims='star centroid_sky'.split(),
                                    coords={'centroid_sky': ['ra', 'dec']})

                ds = xa.Dataset(dict(flux=flux, obj_entropy=eobj, sky_median=msky, sky_entropy=esky, centroid=cpos,
                                     aux=aux, centroids_pix=cpix, centroids_sky=csky))
                ds.to_netcdf(str(rdir.joinpath('{}_{}_{}.nc'.format(object, root.absolute().name, pb))))
