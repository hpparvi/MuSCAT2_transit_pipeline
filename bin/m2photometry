#!/usr/bin/env python

#  MuSCAT2 photometry and transit analysis pipeline
#  Copyright (C) 2019  Hannu Parviainen
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <https://www.gnu.org/licenses/>.
import json
import logging
import warnings

from argparse import ArgumentParser
from datetime import datetime, timedelta
from multiprocessing import Pool
from os import makedirs
from pathlib import Path

import xarray as xa
from astropy.io import fits as pf
from astropy.wcs.wcs import NoConvergence
from astropy.utils.exceptions import AstropyDeprecationWarning
from numpy import zeros, inf, array, c_, nan, full_like, float32, seterr, errstate
from tqdm import tqdm

import matplotlib as mpl
mpl.use('Agg')
import matplotlib.pyplot as pl

from muscat2ph.photometry import ScienceFrame
from muscat2ph.centroider import COMCentroider, DFCOMCentroider
from muscat2ph.catalog import get_toi, get_coords
from muscat2ph.m2obsnight import M2ObservationNight, M2ObservationData

warnings.filterwarnings("error", category=AstropyDeprecationWarning)
seterr(invalid='ignore')

logger = logging.getLogger('m2photometry')

logging.basicConfig(level=logging.INFO)

passbands = 'g r i z_s'.split()

def init(root, pb, apertures, use_wcs, stars_file, cnt_aperture, dc_aperture=0, dc_object=0, centroider='com', shift_g=False,
         create_dc=True):

    global im, cdc, dc_aid, dc_oid
    dc_aid = dc_aperture
    dc_oid = dc_object
    cdc = create_dc
    im = ScienceFrame(root, pb, aperture_radii=apertures, use_wcs=use_wcs)
    im.load_reference_stars(stars_file)
    if not use_wcs and pb == 'g' and shift_g:
        im._ref_centroids_pix[:, 1] += 100
        im._cur_centroids_pix[:, 1] += 100

    if centroider == 'com':
        im.centroider = COMCentroider(im.centroid_star_ids.size, cnt_aperture)
    else:
        im.centroider = DFCOMCentroider(im.centroid_star_ids.size, cnt_aperture)

def photometry(filename):
    try:
        im.load_fits(filename)

        if 'airmass' in im._header:
            airmass = im._header['airmass']
        else:
            airmass = im._header['secz']

        aux = [airmass,
               im._header['exptime'],
               im._header['mjd-strt'] + 0.5 * im._header['exptime'] / 24 / 60 / 60]
        aux = xa.DataArray(aux, dims='quantity', coords={'quantity':'airmass exptime mjd'.split()})

        with errstate(divide='ignore'):
            im.centroid()

        if cdc:
            apt = im.get_aperture(dc_aid, dc_oid)
        else:
            apt = None

        return im.photometry(centroid=False) + (aux, apt)
    except (NoConvergence, ValueError):
        return None


def create_datacube(filename):
    im.load_fits(filename)
    with errstate(divide='ignore'):
        im.centroid()
    #fig = im.centroider.plot_images()
    #fig.savefig(filename.with_suffix('.png').name)
    return im.get_aperture(dc_aid, dc_oid)


if __name__ == '__main__':
    ap = ArgumentParser()
    ap.add_argument('datadir', type=str)
    ap.add_argument('--object', type=str, default=None)
    ap.add_argument('--passband', nargs='+', type=str, default=['r', 'g', 'i', 'z_s'])
    ap.add_argument('--target-catalog-name', type=str, default=None)
    ap.add_argument('--result-dir', type=Path, default=None)
    ap.add_argument('--start-frame', type=int, default=0)
    ap.add_argument('--end-frame', type=int, default=None)
    ap.add_argument('--plot-only', action='store_false', dest='do_photometry', default=True)
    ap.add_argument('--n-processes', type=int, default=5)
    ap.add_argument('--chunksize', type=int, default=1)
    ap.add_argument('--create-dc', action='store_true', default=False)
    ap.add_argument('--dc-obj-id', type=int, default=0)
    ap.add_argument('--dc-apt-id', type=int, default=0)
    ap.add_argument('--tfop', action='store_true', default=False)
    ap.add_argument('--no-tfop', action='store_true', default=False)
    ap.add_argument('--cnt-aperture', type=float, default=20)
    ap.add_argument('--cnt-pmin', type=float, default=80)
    ap.add_argument('--cnt-pmax', type=float, default=95)
    ap.add_argument('--centroider', type=str, choices=['com', 'defocus'], default='com')
    ap.add_argument('--with-wcs-only', action='store_true', default=False)
    ap.add_argument('--ignore-wcs', dest='use_wcs', action='store_false', default=True)
    ap.add_argument('--shift-g', action='store_true', default=False)
    args = ap.parse_args()

    target_sky_coords = None
    target_pix_coords = None

    on = M2ObservationNight(args.datadir, args.object, args.passband)

    # Do the photometry for all the targets
    # -------------------------------------
    for object in on.objects:
        od = M2ObservationData(on, object)
        object = args.target_catalog_name or object
        target_sky_coords = get_coords(object, on.date)
        logging.info(f"Target sky coordinates {target_sky_coords}")

        try:
            toi = get_toi(object)
        except ValueError:
            toi = None

        if args.result_dir:
            rdir = Path(args.result_dir)
        else:
            rdir = Path('.').resolve().joinpath(object, on.night)
            if not rdir.exists():
                makedirs(rdir)

        if not args.no_tfop and toi is not None:
            logging.info(f"Calculating photometry for a TFOP target {object} (TIC {toi.tic}).")
            ticname = 'TIC{:d}-{}'.format(int(toi.tic), str(toi.toi).split('.')[1])
            TFOP = True
        else:
            logging.info(f"Calculating photometry for {object}.")
            TFOP = False

        # Loop over passbands
        # -------------------
        stars_file = rdir / f'{object}_stars.csv'
        with open(rdir / 'parameters.json', 'r') as f:
            parameters = json.load(f)
        apertures = parameters['apertures']

        for ipb, pb in enumerate(od.pbs):
            im = ScienceFrame(on.root, pb, aperture_radii=apertures, use_wcs=args.use_wcs)

            if target_sky_coords is not None:
                im._target_center = target_sky_coords

            if args.use_wcs and len(od.files_with_wcs[pb]) > 0:
                files = od.files_with_wcs[pb]
            else:
                files = od.files[pb]

            files = files[args.start_frame : args.end_frame]

            im.load_reference_stars(stars_file)
            centroider_kwargs = dict(sids=im.centroid_star_ids, aperture_radius=args.cnt_aperture, pmin=args.cnt_pmin, pmax=args.cnt_pmax)

            if args.do_photometry:
                with Pool(processes=args.n_processes, initializer=init,
                          initargs=(on.root, pb, apertures, args.use_wcs, stars_file, args.cnt_aperture,
                                    args.dc_apt_id, args.dc_obj_id, args.centroider, args.shift_g,  args.create_dc)) as pool:
                    result = list(tqdm(pool.imap(photometry, files, chunksize=args.chunksize), total=len(files), desc='Photometry for {}'.format(pb)))
                result = list(filter(lambda r:r is not None, result))

                if args.create_dc:
                    dc = array([r[6] for r in result]).astype(float32)
                    hdu = pf.PrimaryHDU(dc)
                    hdu.writeto(str(rdir.joinpath('{}_{}_{}-dc.fits'.format(object, on.night, pb))), overwrite=True)

                # Centroids
                # ---------
                cpix = xa.DataArray(im._ref_centroids_pix,
                                    name='centroids_pix',
                                    dims='star centroid_pix'.split(),
                                    coords={'centroid_pix': ['x', 'y']})

                if im._ref_centroids_sky is not None:
                    ca = c_[im._ref_centroids_sky.ra.deg, im._ref_centroids_sky.dec.deg]
                else:
                    ca = full_like(array(cpix), nan)

                csky = xa.DataArray(ca,
                                    name='centroids_sky',
                                    dims='star centroid_sky'.split(),
                                    coords={'centroid_sky': ['ra', 'dec']})

                # Photometry
                # ----------
                aux  = xa.concat([r[5] for r in result], 'frame')
                ctime = xa.IndexVariable('mjd', aux.loc[:,'mjd'])
                flux = xa.concat([r[0] for r in result], 'mjd').assign_coords(mjd = ctime)
                msky = xa.concat([r[1] for r in result], 'mjd').assign_coords(mjd = ctime)
                eobj = xa.concat([r[2] for r in result], 'mjd').assign_coords(mjd = ctime)
                esky = xa.concat([r[3] for r in result], 'mjd').assign_coords(mjd = ctime)
                cpos = xa.concat([r[4] for r in result], 'mjd').assign_coords(mjd = ctime)
                ds = xa.Dataset(dict(flux=flux, obj_entropy=eobj, sky_median=msky, sky_entropy=esky, centroid=cpos,
                                     aux=aux, centroids_pix=cpix, centroids_sky=csky))
                ds.to_netcdf(str(rdir.joinpath('{}_{}_{}.nc'.format(object, on.night, pb))))
