#!/usr/bin/env python

from argparse import ArgumentParser

import matplotlib.pyplot as pl
import pandas as pd
import xarray as xa
from astropy.visualization import simple_norm as sn
from numpy import *
from pathlib import Path
from photutils import CircularAperture, CircularAnnulus
from tqdm import tqdm

from muscat2ph.photometry import ScienceFrame, Star

passbands = 'g r i z_s'.split()
N = lambda a: a/median(a)


def aperture_photometry(root, files, pb, stars, outfile=None, istart=0, iend=inf,
                        apertures=(10, 15, 20), save_datacubes=False, parallel=False):
    istart = max(0, istart)
    iend = min(iend, len(files))
    nframes = iend - istart
    napt = len(apertures)

    im = ScienceFrame(root, pb)
    im.load_fits(files[istart])
    nstars = stars.shape[0]

    stars = [Star(ra, dec, apertures=apertures) for ra,dec in stars.values]

    cframe = arange(istart, iend)
    cstar = arange(nstars)
    capt = list(apertures)
    caxis = ['x','y']

    aux = xa.DataArray(zeros([nframes, 3]),
                       dims='frame quantity'.split(),
                       coords={'frame': cframe,
                               'quantity': 'airmass exptime mjd'.split()})

    flux = xa.DataArray(zeros([nframes, nstars, napt]), name='flux',
                        dims='frame star aperture'.split(),
                        coords={'frame': cframe,
                                'star': cstar,
                                'aperture': capt})

    eobj = xa.DataArray(zeros([nframes, nstars, napt]),
                        dims='frame star aperture'.split(),
                        name='aperture_entropy',
                        coords={'frame': cframe,
                                'star': cstar,
                                'aperture': capt})

    msky = xa.DataArray(zeros([nframes, nstars]), name='sky_median',
                        dims='frame star'.split(),
                        coords={'frame': cframe,
                                'star': cstar})

    esky = xa.DataArray(zeros([nframes, nstars]), name='sky_entropy',
                        dims='frame star'.split(),
                        coords={'frame': cframe,
                                'star': cstar})

    pos = xa.DataArray(zeros([nframes, nstars, 2]), name='centroids',
                       dims='frame star axis'.split(),
                       coords={'frame': cframe,
                               'star': cstar,
                               'axis':caxis})

    #if save_datacubes:
    #    shape = CircularAperture(im._aps.positions, apertures[-1]).to_mask()[0].shape
    #    dcubes = [zeros([nframes, shape[0], shape[1]]) for i in range(nstars)]

    if parallel:
        from ipyparallel import Client
        rc = Client()
        dv = rc[:]
        dv.execute("from muscat2ph.photometry import ScienceFrame, Star")
        dv.push(dict(im=im, files=files), block=True)
        dv.scatter('lstars', stars, block=True)

        @dv.remote(block=True)
        def phot(iframe):
            im.load_fits(files[iframe])
            rs = [s.photometry(im) for s in lstars]

    for iframe, f in enumerate(tqdm(files[istart:iend])):
        ifr = iframe + istart
        im.load_fits(f)

        if parallel:
            dv.execute("im.load_fits(files[{}])".format(iframe), block=True)
            dv.execute('rs = [s.photometry(im) for s in lstars]', block=True)
            #phot(iframe)
            rs = dv.gather('rs')
            #rs = dv.map_sync(lambda s: s.photometry(im), stars)
        else:
            rs = list(map(lambda s: s.photometry(im), stars))

        for istar, (fobj, cmsky, ceobj, cesky, ccnt) in enumerate(rs):
            flux[iframe, istar, :] = fobj
            eobj[iframe, istar, :] = ceobj
            msky[iframe, istar] = cmsky
            esky[iframe, istar] = cesky
            pos[iframe, istar] = ccnt

        aux.loc[ifr, 'airmass'] = im._header['airmass']
        aux.loc[ifr, 'exptime'] = im._header['exptime']
        aux.loc[ifr, 'mjd'] = im._header['mjd-strt'] + 0.5 * im._header['exptime'] / 24 / 60 / 60

    #     if save_datacubes:
    #         for iapt, m in enumerate(masks):
    #             dcubes[iapt][i, :, :] = m.cutout(im.reduced)
    #
    if outfile:
        ds = xa.Dataset(dict(flux=flux, obj_entropy=eobj, sky_median=msky, sky_entropy=esky, centroid=pos, aux=aux))
        ds.to_netcdf(outfile + '.nc')
    #
    # if save_datacubes:
    #     hdul = pf.HDUList([pf.PrimaryHDU()] + [pf.ImageHDU(d) for d in dcubes])
    #     hdul.writeto(outfile + '-dc.fits', overwrite=True)

    #return flux, aux


if __name__ == '__main__':
    ap = ArgumentParser()
    ap.add_argument('datadir', type=str)
    ap.add_argument('object', type=str)
    ap.add_argument('passband', choices='g r i z_s all'.split())
    ap.add_argument('--reference-passband', choices='g r i z_s'.split(), default='r')
    ap.add_argument('--result-dir', type=str, default='.')
    ap.add_argument('--n-stars', type=int, default=8)
    ap.add_argument('--edge-limit', type=float, default=30)
    ap.add_argument('--start-frame', type=int, default=0)
    ap.add_argument('--end-frame', type=int, default=inf)
    ap.add_argument('--plot-only', action='store_false', dest='do_photometry', default=True)
    ap.add_argument('--parallel', action='store_true', default=False)
    ap.add_argument('--save-datacubes', action='store_true', default=False)
    ap.add_argument('--save-stars', action='store_true', default=False)
    ap.add_argument('--load-stars', action='store_true', default=False)
    ap.add_argument('-n', '--dry-run', action='store_true', dest='dry_run', default=False)
    args = ap.parse_args()

    root = Path(args.datadir)
    rdir = Path(args.result_dir)

    files = {pb : list(root.joinpath('obj', args.object, pb).glob('MCT2?_*.fits')) for pb in 'g r i z_s'.split()}
    pbs = [args.passband] if args.passband != 'all' else 'g r i z_s'.split()

    for ipb, pb in enumerate(pbs):
        im = ScienceFrame(root, pb)
        im.load_fits(files[pb][args.start_frame])

        # Find, save, and load tn brightest stars
        # ---------------------------------------
        if args.load_stars:
            stars_sky = pd.read_csv('{}_stars.csv'.format(args.object), index_col=0)
            im.set_stars(stars_sky)
        else:
            im.find_stars(maxn=args.n_stars)
            stars_sky = im._centroids
            if args.save_stars and ipb==0:
                stars_sky.to_csv('{}_stars.csv'.format(args.object))

        # Masterframe plot with apertures
        # -------------------------------
        fig1,ax1 = pl.subplots(figsize=(7,7))
        ax1 = im.plot_reduced(minp=90, offset=10, ax=ax1)
        fig1.savefig('{}-{}.png'.format(args.object, pb))
        fig1.tight_layout()

        # Individual aperture plots
        # -------------------------
        fig2, axs2 = pl.subplots(1, 7, figsize=(11, 2.5), sharex=True, sharey=True)
        for ax, s in zip(axs2, im._stars):
            p = array(s.centroid)
            m = s._asky.to_mask()[0]
            d = m.cutout(im.reduced)
            ax.imshow(d, norm=sn(d, 'log'))
            o = array([m.bbox.slices[1].start, m.bbox.slices[0].start])
            ask = CircularAnnulus(p - o, s._asky.r_in, s._asky.r_out)
            [CircularAperture(p - o, r).plot(ax=ax, ls='--') for r in s.apertures]
            ask.plot(ax=ax)
        fig2.tight_layout()
        fig2.savefig('{}-{}-apertures.png'.format(args.object, pb))

        # Photometry
        # ----------
        if args.do_photometry:
            aperture_photometry(root, files[pb], pb, stars_sky, '{}-{}'.format(args.object, pb),
                                args.start_frame, args.end_frame, parallel=args.parallel,
                                save_datacubes=args.save_datacubes)
