#!/usr/bin/env python
import warnings
import sys
from argparse import ArgumentParser

from numpy import clip, array, ravel

from astropy.table import Table
import matplotlib.pyplot as pl
from matplotlib.pyplot import subplots
from numpy.random.mtrand import normal
from tqdm import tqdm
from emcee import EnsembleSampler
from pyde import DiffEvol

from scipy.optimize import minimize
from corner import corner

sys.path.append('../muscat2ta')

from muscatreader import *
from parameter import *
from lpf import *


if __name__ == '__main__':
    ap = ArgumentParser()
    ap.add_argument('name', type=str, default='hat-p-20')
    ap.add_argument('data_dir', type=str, default='../notebooks/data/hat_p_20/lc')
    ap.add_argument('--plot-dir', type=str, default='.')
    ap.add_argument('--npop', default=100, type=int)
    ap.add_argument('--niter-od', default=30, type=int)
    ap.add_argument('--niter-de', default=100, type=int)
    ap.add_argument('--niter-mc', default=500, type=int)
    ap.add_argument('--npasses', default=2, type=int)
    args = ap.parse_args()

    filters = 'g r z'.split()
    mr = MuSCATReader(args.data_dir)

    # Outlier detection and rejection
    # -------------------------------
    lpf = StudentLSqLPF(args.name, mr.datasets, filters, nthreads=1, shift_tc=True)
    de = DiffEvol(lpf, clip(lpf.ps.bounds, -1, 1), args.npop, maximize=True, F=0.50, C=0.25)
    de._population[:,:] = lpf.create_pv_population(args.npop)
    sampler = EnsembleSampler(de.n_pop, de.n_par, lpf)

    for ip in range(args.npasses):
        for _ in tqdm(de(args.niter_od), total=args.niter_od, desc='Outlier detection pass {:2d}'.format(ip+1)):
            pass

        with warnings.catch_warnings():
            warnings.simplefilter('ignore')
            res = minimize(lambda pv:-lpf(pv), de.minimum_location, method='Powell')

        masks = lpf.sigma_clip(res.x, sigma=3)
        for m1,m2 in zip(lpf.masks, masks):
            m1[m1] *= m2

        lpf._setup_arrays(lpf.masks)

    fig,axs = subplots(1,3,figsize=(13,4), sharey=True, sharex=True)
    fluxes_m = lpf.compute_lc_model(res.x)
    [ax.plot(time, flux, '.', alpha=0.4) for ax,time,flux in zip(axs, lpf.times, lpf.fluxes)]
    [ax.plot(time, flux, 'k', alpha=1.0) for ax,time,flux in zip(axs, lpf.times, fluxes_m)]
    fig.tight_layout()
    pl.show()

    # Characterisation
    # -----------------

    lpfn = GPLPF(args.name, mr.datasets, filters, nthreads=1, shift_tc=True)
    lpfn._setup_arrays(lpf.masks)
    den = DiffEvol(lpfn, clip(lpfn.ps.bounds, -1, 1), args.npop, maximize=True, F=0.50, C=0.25)
    sampler = EnsembleSampler(den.n_pop, den.n_par, lpfn)

    lpfn.optimize_hps(res.x)
    den._population[:, :] = lpfn.create_pv_population(args.npop)
    den._population[:, :5] = de._population[:, :5]
    den._population[:, lpfn._slbl] = array([normal(c, 1e-3, size=args.npop) for c in ravel(lpfn.lsq)]).T

    for _ in tqdm(den(args.niter_de), total=args.niter_de, desc='Final global optimisation'):
        pass

    for _ in tqdm(sampler.sample(den.population, iterations=args.niter_mc, thin=10), total=args.niter_mc, desc='MCMC sampling'):
        pass

    fc = sampler.chain.reshape([-1, len(lpfn.ps)])
    tb = Table(fc, names=lpfn.ps.names)
    tb.write(args.name+'.fits')

    rr = minimize(lambda pv: -lpfn(pv), den.minimum_location, method='Nelder-Mead')
    fluxes_s = [lpfn.gps[i].predict(lpfn.fluxes[i]-fluxes_m[i], lpfn.auxs[i][:,[1,3,4,5]], return_cov=False) for i in range(3)]
    fig,axs = subplots(1,3,figsize=(13,4), sharey=True, sharex=True)
    [ax.plot(time, flux, '.', alpha=0.4) for ax,time,flux in zip(axs, lpf.times, lpf.fluxes)]
    fluxes_m = lpfn.compute_lc_model(rr.x)
    [ax.plot(time, flux+fs, 'k', alpha=1) for ax,time,flux,fs in zip(axs, lpf.times, fluxes_m, fluxes_s)]
    fig.tight_layout()
    pl.show()